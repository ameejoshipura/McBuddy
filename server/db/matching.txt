The following is the proposed DB schema for the matching algorithm:

We will be using string datatypes to keep things simple for the prototype.

Table profiles:

pid (int) - McBuddy profile ID, unique to every member
qbid (string) - link to associated profile in QB
classlist (string) - see below
schedule (string) - see below

classlist data structure: e.g. "MATH363|COMP360|ECSE428". Classes separated by '|' characters. Any whitespace should be ignored, case insensitive

schedule data structure: e.g. m = morning, a = afternoon, e = evening. Ignore whitespace, case-insensitive. stored as json

"{
	monday : "mae",
	tuesday : "ma",
	wednesday : "ma" ,
	thursday : "" ,
	friday : "",
	saterday : "",
	sunday : "",

}"

Since this is just a prototype, it's safe to assume the strings will be well-formed. If there's a problem, just skip the match.

The matching algorithm should work as follows:

Given a profile (i.e. one entry in the table, i.e. a pid, qbid, classlist, and schedule), compare the class list against the whole table and build a list of people who match on a class. Then, from that smaller match list, remove anybody whose schedules don't match. Then return a list of table entries.

For example, person A has class list "ECSE428|ECSE306" and is only available Monday mornings. Build a list of people who have either class ECSE428 or ECSE306 (or both) on their class lists, and call this built list "partial matches". Then, from the partial matches, remove anybody who isn't free Monday mornings. Then return that list.
